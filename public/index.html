<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>â˜ï¸ DialBot ğŸ¤–</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="main-layout">
  <!-- Left Panel: Controls -->
  <div class="control-panel">
    <div class="header-with-help">
      <h2>â˜ï¸ DialBot ğŸ¤–</h2>
      <button id="helpBtn" class="help-btn" title="Help & Documentation">â“˜</button>
    </div>
    
    <div class="control-section">
      <!-- Profile Selection -->
      <div class="profile-selector">
        <select id="profile-select" class="profile-select">
          <option value="">No Profile - Manual Mode</option>
        </select>
        <button id="editProfiles" class="edit-profiles-btn" title="Edit profiles">âœï¸</button>
      </div>
      
      <div class="input-group">
        <input id="phone" type="tel" placeholder="+1xxxxxxxxxx"/>
        <select id="phone-select" class="phone-select">
          <option value="">ğŸ“– Phonebook</option>
        </select>
      </div>
      
      <div class="button-group">
        <button id="callBtn" disabled>ğŸ“ Start Call</button>
        <button id="endBtn" disabled>ğŸ“´ End Call</button>
        <button id="retryBtn" disabled>ğŸ”„ Hang-up & Redial</button>
        <button id="settingsBtn">âš™ï¸ Settings</button>
      </div>
      
    </div>
    
    <!-- Status Section -->
    <div class="status-section">
      <div id="status" class="loading">ğŸ”„ Loading Twilio Deviceâ€¦</div>
      
      <div id="callInfo" style="display:none;">
        <div class="status-header">
          <h3 id="statusTitle">ğŸ“ Ready</h3>
          <div class="timer-container">
            <div id="callTimer" class="timer">00:00</div>
            <div id="redialTimer" class="timer redial-timer" style="display:none;">
              <span class="timer-label">Redial in:</span>
              <span id="redialCountdown">00:00</span>
            </div>
          </div>
        </div>
        <div class="status-indicators">
          <div class="indicator" id="dmvStatus">
            <span class="icon">ğŸ¢</span>
            <span class="label">DMV Status</span>
            <span class="value" id="dmvStatusValue">-</span>
          </div>
          <div class="indicator" id="humanStatus">
            <span class="icon">ğŸ‘¤</span>
            <span class="label">Human Agent</span>
            <span class="value" id="humanStatusValue">-</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Keypad -->
    <div class="keypad-section">
      <h4>ğŸ“± Keypad</h4>
      <div id="pad"></div>
      <div class="voice-commands">
        <button id="sayAgentBtn" disabled>ğŸ—£ï¸ Say "Agent"</button>
      </div>
    </div>
    
    <!-- Call History -->
    <div class="history-section">
      <div class="section-header">
        <h4>ğŸ“ Recent Calls</h4>
        <button id="clearHistory" class="clear-history-btn" title="Clear history">ğŸ—‘ï¸</button>
      </div>
      <div id="callHistory" class="call-history">
        <div class="history-placeholder">No recent calls</div>
      </div>
    </div>
    
  </div>
  
  <!-- Right Panel: Transcripts and Debug Log -->
  <div class="transcript-panel">
    <div class="transcript-header">
      <h3>ğŸ™ï¸ Recording Status</h3>
      <div class="transcript-actions">
        <button id="viewRecordings" title="View recordings">ğŸ“¼ Recordings</button>
      </div>
    </div>
    <div id="recordingStatus" class="recording-status">
      <div class="status-placeholder">
        <span class="status-icon">â­•</span>
        <span class="status-text">Ready to record</span>
      </div>
    </div>
    
    <!-- Recordings List -->
    <div id="recordingsList" class="recordings-list" style="display: none;">
      <div class="recordings-header">
        <h4>ğŸ“¼ Call Recordings</h4>
        <button id="closeRecordings" class="close-btn">âœ•</button>
      </div>
      <div id="recordingsContent" class="recordings-content">
        <div class="recordings-placeholder">No recordings yet</div>
      </div>
    </div>
    
    <!-- Call Notes -->
    <div class="notes-section">
      <div class="notes-header">
        <h4>ğŸ“ Call Notes</h4>
        <div class="notes-actions">
          <button id="copyNotes" class="notes-btn" title="Copy notes">ğŸ“‹ Copy</button>
          <button id="exportNotes" class="notes-btn" title="Export as .txt">ğŸ’¾ Export</button>
          <button id="clearNotes" class="notes-btn" title="Clear notes">ğŸ—‘ï¸ Clear</button>
        </div>
      </div>
      <textarea id="callNotes" class="notes-textarea" placeholder="Type your notes here..."></textarea>
    </div>
    
    <!-- Debug Log -->
    <div class="log-section">
      <div class="log-header">
        <h4>ğŸ” Debug Log</h4>
        <button id="copyLogs" class="copy-logs-btn" title="Copy logs">ğŸ“‹</button>
      </div>
      <div id="logBox"></div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>âš™ï¸ Settings</h3>
      <span class="close">&times;</span>
    </div>
    <div class="modal-body">
      <!-- Audio Device Selection -->
      <div class="settings-section">
        <h4>ğŸ”Š Audio Devices</h4>
        <div class="device-group">
          <label for="speakerSelect">Speaker:</label>
          <select id="speakerSelect">
            <option value="">Select speaker...</option>
          </select>
        </div>
        <div class="device-group">
          <label for="micSelect">Microphone:</label>
          <select id="micSelect">
            <option value="">Select microphone...</option>
          </select>
        </div>
        <button id="refreshDevices">ğŸ”„ Refresh Devices</button>
        <button id="testMicrophone">ğŸ¤ Test Microphone</button>
      </div>

      <!-- Redial Settings -->
      <div class="settings-section">
        <h4>ğŸ”„ Redial Settings</h4>
        <div class="device-group">
          <label for="redialInterval">Redial Interval:</label>
          <select id="redialInterval">
            <option value="60000">1 minute</option>
            <option value="300000">5 minutes</option>
            <option value="600000">15 minutes</option>
            <option value="1800000">30 minutes</option>
            <option value="2700000">45 minutes</option>
            <option value="3600000">1 hour</option>
            <option value="7200000">2 hours</option>
            <option value="10800000">3 hours</option>
            <option value="14400000">4 hours</option>
            <option value="18000000">5 hours</option>
          </select>
        </div>
        <div class="device-group">
          <label>
            <input type="checkbox" id="autoHangupAgentsBusy" checked> 
            <span style="font-weight: 600;">Auto-hangup when agents busy</span>
          </label>
          <div style="font-size: 0.9em; color: #999; margin-top: 5px; margin-left: 20px;">
            Automatically hang up and redial when "all agents are busy" is detected
          </div>
        </div>
      </div>

      <!-- Alert Sounds -->
      <div class="settings-section">
        <h4>ğŸ”” Alert Sounds</h4>
        <div class="alert-sounds-container">
          <div class="device-group">
            <label for="alertVolume">Volume Level:</label>
            <select id="alertVolume">
              <option value="normal">Normal</option>
              <option value="low">Low</option>
            </select>
          </div>
          
          <div class="alert-sound-item">
            <label>Human Agent Detected:</label>
            <div class="sound-controls">
              <select id="humanDetectedSound" class="alert-sound-select">
                <option value="none">None</option>
                <option value="beep">Beep</option>
                <option value="chime">Chime</option>
                <option value="bell">Bell</option>
                <option value="doubleBeep">Double Beep</option>
              </select>
              <button class="test-sound-btn" data-event="humanDetected">ğŸ”Š Test</button>
            </div>
          </div>
          
          <div class="alert-sound-item">
            <label>Call Connected:</label>
            <div class="sound-controls">
              <select id="callConnectedSound" class="alert-sound-select">
                <option value="none">None</option>
                <option value="beep">Beep</option>
                <option value="chime">Chime</option>
                <option value="bell">Bell</option>
                <option value="doubleBeep">Double Beep</option>
              </select>
              <button class="test-sound-btn" data-event="callConnected">ğŸ”Š Test</button>
            </div>
          </div>
          
          <div class="alert-sound-item">
            <label>Agents Busy:</label>
            <div class="sound-controls">
              <select id="agentsBusySound" class="alert-sound-select">
                <option value="none">None</option>
                <option value="beep">Beep</option>
                <option value="chime">Chime</option>
                <option value="bell">Bell</option>
                <option value="doubleBeep">Double Beep</option>
                <option value="error">Error</option>
              </select>
              <button class="test-sound-btn" data-event="agentsBusy">ğŸ”Š Test</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Phonebook -->
      <div class="settings-section">
        <h4>ğŸ“ Phonebook</h4>
        <div class="phonebook-container">
          <div class="phonebook-add">
            <input type="text" id="phonebook-name" placeholder="Contact name">
            <input type="tel" id="phonebook-number" placeholder="+1xxxxxxxxxx">
            <button id="phonebook-add-btn">â• Add</button>
          </div>
          <div id="phonebook-list" class="phonebook-list">
            <!-- Contacts will be populated here -->
          </div>
        </div>
      </div>

      <!-- Business Hours Settings -->
      <div class="settings-section">
        <h4>ğŸ• Business Hours</h4>
        <div class="device-group">
          <label>
            <input type="checkbox" id="disableBusinessHours"> 
            <span style="color: #e74c3c; font-weight: 600;">Disable business hours enforcement</span>
          </label>
        </div>
        <div class="device-group">
          <label for="timezone">Time Zone:</label>
          <select id="timezone">
            <option value="America/New_York">Eastern Time</option>
            <option value="America/Chicago">Central Time</option>
            <option value="America/Denver">Mountain Time</option>
            <option value="America/Los_Angeles">Pacific Time</option>
          </select>
        </div>
        <div class="device-group">
          <label>Operating Hours:</label>
          <div class="hours-grid">
            <label><input type="checkbox" id="monday" checked> Monday</label>
            <input type="time" id="monday-start" value="08:00">
            <input type="time" id="monday-end" value="17:00">
            
            <label><input type="checkbox" id="tuesday" checked> Tuesday</label>
            <input type="time" id="tuesday-start" value="08:00">
            <input type="time" id="tuesday-end" value="17:00">
            
            <label><input type="checkbox" id="wednesday" checked> Wednesday</label>
            <input type="time" id="wednesday-start" value="08:00">
            <input type="time" id="wednesday-end" value="17:00">
            
            <label><input type="checkbox" id="thursday" checked> Thursday</label>
            <input type="time" id="thursday-start" value="08:00">
            <input type="time" id="thursday-end" value="17:00">
            
            <label><input type="checkbox" id="friday" checked> Friday</label>
            <input type="time" id="friday-start" value="08:00">
            <input type="time" id="friday-end" value="17:00">
            
            <label><input type="checkbox" id="saturday"> Saturday</label>
            <input type="time" id="saturday-start" value="09:00" disabled>
            <input type="time" id="saturday-end" value="13:00" disabled>
            
            <label><input type="checkbox" id="sunday"> Sunday</label>
            <input type="time" id="sunday-start" value="09:00" disabled>
            <input type="time" id="sunday-end" value="13:00" disabled>
          </div>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button id="saveSettings">ğŸ’¾ Save Settings</button>
    </div>
  </div>
</div>

<script src="https://sdk.twilio.com/js/client/v1.13/twilio.min.js"></script>
<script>
(async () => {
  /* DOM helpers */
  const $   = id => document.getElementById(id);
  const log = m => { const t=new Date().toLocaleTimeString();
                     logBox.textContent += `[${t}] ${m}\n`;
                     logBox.scrollTop = logBox.scrollHeight; };

  // Helper function to format time
  const formatTime = (ms) => {
    const seconds = Math.floor(ms / 1000);
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;
  };

  const status=$('status'), padDiv=$('pad'), logBox=$('logBox');
  const callBtn=$('callBtn'), endBtn=$('endBtn'), retryBtn=$('retryBtn');
  const sayAgentBtn=$('sayAgentBtn');
  const settingsBtn=$('settingsBtn'), phoneInp=$('phone');
  const speakerSelect=$('speakerSelect'), micSelect=$('micSelect');
  const refreshDevicesBtn=$('refreshDevices'), redialIntervalSelect=$('redialInterval');
  const settingsModal=$('settingsModal'), saveSettingsBtn=$('saveSettings');
  const phoneSelect=$('phone-select'), phonebookList=$('phonebook-list');
  const phonebookAddBtn=$('phonebook-add-btn'), phonebookName=$('phonebook-name');
  const phonebookNumber=$('phonebook-number'), copyLogsBtn=$('copyLogs');
  const profileSelect=$('profile-select'), editProfilesBtn=$('editProfiles');
  const helpBtn=$('helpBtn'), callHistory=$('callHistory'), clearHistoryBtn=$('clearHistory');
  const testMicBtn=$('testMicrophone');
  const autoHangupCheckbox=$('autoHangupAgentsBusy');
  
  // Enhanced UI elements
  const callInfo=$('callInfo'), statusTitle=$('statusTitle');
  const callTimer=$('callTimer'), dmvStatusValue=$('dmvStatusValue');
  const humanStatusValue=$('humanStatusValue');
  const redialTimer=$('redialTimer'), redialCountdown=$('redialCountdown');
  const callNotesTextarea=$('callNotes'), copyNotesBtn=$('copyNotes');
  const exportNotesBtn=$('exportNotes'), clearNotesBtn=$('clearNotes');

  /* State */
  let activeConn=null, currentSid=null, lastNumber=null;
  let redialDelay=60000, redialTimerId=null, redialCount=0;
  let deviceReady=false;
  let tokenRefreshTimer=null;
  let isInitializingDevice=false;  // Prevent re-initialization loops
  let callStateInterval=null;
  let callStartTime=null;
  let callTimerInterval=null;
  let redialCountdownInterval=null;
  let currentProfile=null;
  let profiles=[];

  /* Audio Context Management */
  let audioContext = null;
  const initAudioContext = () => {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioContext.state === 'suspended') {
      return audioContext.resume();
    }
    return Promise.resolve();
  };

  /* Sound Manager for Alerts */
  class SoundManager {
    constructor() {
      this.sounds = {
        beep: { frequency: 800, duration: 200, type: 'sine' },
        chime: { frequencies: [523, 659, 784], duration: 150, type: 'sine' },
        bell: { frequency: 440, duration: 300, type: 'triangle' },
        doubleBeep: { frequencies: [600, 800], duration: 150, type: 'sine' },
        error: { frequency: 200, duration: 400, type: 'sawtooth' }
      };
      
      this.volumes = {
        normal: 0.3,
        low: 0.1
      };
      
      // Load saved preferences
      const savedPrefs = localStorage.getItem('dialbot-alert-sounds');
      if (savedPrefs) {
        this.preferences = JSON.parse(savedPrefs);
      } else {
        this.preferences = {
          humanDetected: 'chime',
          callConnected: 'beep',
          agentsBusy: 'doubleBeep',
          error: 'error',
          volume: 'normal'
        };
      }
    }
    
    async playAlert(eventType) {
      const soundType = this.preferences[eventType] || 'beep';
      const volume = this.volumes[this.preferences.volume || 'normal'];
      
      if (soundType === 'none') return;
      
      await initAudioContext();
      const sound = this.sounds[soundType];
      
      if (sound.frequencies) {
        // Play multiple frequencies in sequence
        for (let i = 0; i < sound.frequencies.length; i++) {
          setTimeout(() => {
            this.playTone(sound.frequencies[i], sound.duration, sound.type, volume);
          }, i * sound.duration);
        }
      } else {
        // Play single frequency
        this.playTone(sound.frequency, sound.duration, sound.type, volume);
      }
    }
    
    playTone(frequency, duration, type, volume) {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = type;
      gainNode.gain.value = volume;
      
      // Fade out to prevent clicking
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + duration / 1000);
    }
    
    testSound(soundType) {
      const volume = this.volumes[this.preferences.volume || 'normal'];
      const sound = this.sounds[soundType];
      
      if (!sound) return;
      
      initAudioContext().then(() => {
        if (sound.frequencies) {
          for (let i = 0; i < sound.frequencies.length; i++) {
            setTimeout(() => {
              this.playTone(sound.frequencies[i], sound.duration, sound.type, volume);
            }, i * sound.duration);
          }
        } else {
          this.playTone(sound.frequency, sound.duration, sound.type, volume);
        }
      });
    }
    
    savePreferences() {
      localStorage.setItem('dialbot-alert-sounds', JSON.stringify(this.preferences));
    }
  }
  
  const soundManager = new SoundManager();

  /* Profile Management */
  const loadProfiles = async () => {
    try {
      const response = await fetch('/api/profiles');
      profiles = await response.json();
      
      profileSelect.innerHTML = '<option value="">No Profile - Manual Mode</option>';
      
      profiles.forEach(profile => {
        const option = document.createElement('option');
        option.value = profile.id;
        option.textContent = `${profile.icon} ${profile.name}`;
        profileSelect.appendChild(option);
      });
      
      // Check for saved profile preference
      const savedProfileId = localStorage.getItem('dialbot-selected-profile');
      if (savedProfileId && profiles.find(p => p.id === savedProfileId)) {
        profileSelect.value = savedProfileId;
        await loadProfile(savedProfileId);
      }
      
      log('Profiles loaded successfully');
    } catch (err) {
      console.error('Failed to load profiles:', err);
      log('Failed to load profiles');
    }
  };
  
  const loadProfile = async (profileId) => {
    if (!profileId) {
      currentProfile = null;
      log('No profile selected - manual mode');
      return;
    }
    
    const profile = profiles.find(p => p.id === profileId);
    if (!profile) return;
    
    currentProfile = profile;
    localStorage.setItem('dialbot-selected-profile', profileId);
    
    // Update business hours from profile
    if (profile.businessHours) {
      const hours = profile.businessHours;
      if (hours.timezone) $('timezone').value = hours.timezone;
      
      ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].forEach(day => {
        if (hours[day]) {
          $(day).checked = hours[day].enabled;
          $(`${day}-start`).value = hours[day].start;
          $(`${day}-end`).value = hours[day].end;
          $(`${day}-start`).disabled = !hours[day].enabled;
          $(`${day}-end`).disabled = !hours[day].enabled;
        }
      });
    }
    
    // Update redial settings from profile
    if (profile.redialSettings) {
      const redialMs = (profile.redialSettings.delaySeconds || 60) * 1000;
      redialDelay = redialMs;
      redialIntervalSelect.value = redialMs.toString();
    }
    
    // Update phonebook from profile
    if (profile.numbers && profile.numbers.length > 0) {
      // Add profile numbers to phonebook UI
      profile.numbers.forEach(num => {
        phoneSelect.innerHTML += `<option value="${num.number}">${profile.icon} ${num.name} (${num.number})</option>`;
      });
    }
    
    log(`Profile loaded: ${profile.name}`);
    status.textContent = `${profile.icon} ${profile.name} profile active`;
  };
  
  // Profile select handler
  profileSelect.onchange = () => {
    loadProfile(profileSelect.value);
  };
  
  // Edit profiles handler (placeholder for now)
  editProfilesBtn.onclick = () => {
    alert('Profile editor coming soon! For now, edit the JSON files in public/profiles/');
  };
  
  // Help button handler
  helpBtn.onclick = () => {
    const helpModal = document.createElement('div');
    helpModal.className = 'modal';
    helpModal.style.display = 'block';
    helpModal.innerHTML = `
      <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
          <h3>ğŸ“š DialBot Help & Documentation</h3>
          <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
        </div>
        <div class="modal-body" style="padding: 2rem;">
          <div class="help-section">
            <h4 style="color: #00d9ff; margin-bottom: 1rem;">ğŸš€ Getting Started</h4>
            <ol style="line-height: 1.8; color: #e0e0e0;">
              <li><strong>Select a Profile:</strong> Choose a pre-configured profile (DMV, Healthcare, etc.) or use Manual Mode</li>
              <li><strong>Enter Phone Number:</strong> Type the number or select from your phonebook</li>
              <li><strong>Start Call:</strong> Click the call button to begin dialing</li>
              <li><strong>Automatic Navigation:</strong> DialBot will listen and respond to IVR prompts based on the profile</li>
              <li><strong>Human Detection:</strong> When a human agent is detected, you'll be connected automatically</li>
            </ol>
          </div>
          
          <div class="help-section" style="margin-top: 2rem;">
            <h4 style="color: #00d9ff; margin-bottom: 1rem;">ğŸ“‹ Profile Features</h4>
            <ul style="line-height: 1.8; color: #e0e0e0;">
              <li><strong>DMV Profiles:</strong> Automatically say "Agent" to navigate to human representatives</li>
              <li><strong>Healthcare:</strong> Navigate appointment menus and pharmacy options</li>
              <li><strong>Utilities:</strong> Handle billing, outage reports, and service requests</li>
              <li><strong>Custom:</strong> Create your own patterns in the profiles/*.json files</li>
            </ul>
          </div>
          
          <div class="help-section" style="margin-top: 2rem;">
            <h4 style="color: #00d9ff; margin-bottom: 1rem;">âš™ï¸ Key Features</h4>
            <ul style="line-height: 1.8; color: #e0e0e0;">
              <li><strong>Immediate Audio:</strong> Hear the call as soon as it's answered - no waiting</li>
              <li><strong>Manual Commands:</strong> Say "Agent" with button click</li>
              <li><strong>Pattern Detection:</strong> Automatic detection of "agents busy" and other patterns</li>
              <li><strong>Auto-Redial:</strong> Automatically redial when all agents are busy</li>
              <li><strong>Business Hours:</strong> Only dial during configured hours</li>
              <li><strong>Call Recording:</strong> Records conversations with human agents</li>
              <li><strong>Real-time Transcripts:</strong> See what's being said in real-time</li>
              <li><strong>Call History:</strong> Track your recent calls and outcomes</li>
            </ul>
          </div>
          
          <div class="help-section" style="margin-top: 2rem; padding: 1rem; background: rgba(0, 217, 255, 0.1); border-radius: 8px;">
            <p style="color: #00d9ff; margin: 0;">
              <strong>ğŸ’¡ Tip:</strong> Configure audio devices in Settings before making your first call!
            </p>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(helpModal);
    
    // Close on background click
    helpModal.onclick = (e) => {
      if (e.target === helpModal) helpModal.remove();
    };
  };
  
  // Call history management
  const addToCallHistory = (number, duration, status) => {
    const history = JSON.parse(localStorage.getItem('dialbot-call-history') || '[]');
    history.unshift({
      number,
      duration,
      status,
      timestamp: new Date().toISOString(),
      profile: currentProfile ? currentProfile.name : 'Manual'
    });
    
    // Keep only last 10 calls
    if (history.length > 10) history.pop();
    
    localStorage.setItem('dialbot-call-history', JSON.stringify(history));
    updateCallHistoryUI();
  };
  
  const updateCallHistoryUI = () => {
    const history = JSON.parse(localStorage.getItem('dialbot-call-history') || '[]');
    
    if (history.length === 0) {
      callHistory.innerHTML = '<div class="history-placeholder">No recent calls</div>';
      return;
    }
    
    callHistory.innerHTML = history.map(call => {
      const date = new Date(call.timestamp);
      const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const dateStr = date.toLocaleDateString();
      
      return `
        <div class="history-item">
          <div class="history-number">${call.number}</div>
          <div class="history-details">
            <span class="history-profile">${call.profile}</span>
            <span class="history-duration">${formatTime(call.duration)}</span>
            <span class="history-status">${call.status}</span>
          </div>
          <div class="history-time">${timeStr} ${dateStr}</div>
        </div>
      `;
    }).join('');
  };
  
  clearHistoryBtn.onclick = () => {
    if (confirm('Clear all call history?')) {
      localStorage.removeItem('dialbot-call-history');
      updateCallHistoryUI();
      log('Call history cleared');
    }
  };

  /* Token Refresh */
  const refreshToken = async () => {
    try {
      const { token } = await fetch('/refresh-token').then(r=>r.json());
      Twilio.Device.setup(token, {debug: false});
      log('Token refreshed');
    } catch (err) {
      log(`Token refresh error: ${err.message}`);
      status.textContent = 'âš ï¸ Token refresh failed';
    }
  };
  
  const startTokenRefresh = () => {
    // Refresh token every 50 minutes (before 1-hour expiry)
    if (tokenRefreshTimer) clearInterval(tokenRefreshTimer);
    tokenRefreshTimer = setInterval(refreshToken, 50 * 60 * 1000);
  };

  /* Business Hours Check */
  const isWithinBusinessHours = () => {
    // Check if business hours are disabled
    const disabled = localStorage.getItem('dialbot-disable-business-hours');
    if (disabled === 'true') {
      return true; // Allow calls anytime
    }
    
    const saved = localStorage.getItem('dialbot-business-hours');
    if (!saved) return true; // Default to allow if not configured
    
    const hours = JSON.parse(saved);
    const timezone = hours.timezone || 'America/New_York';
    
    // Get current time in specified timezone
    const now = new Date();
    const options = { timeZone: timezone, hour12: false };
    const timeStr = now.toLocaleTimeString('en-US', options);
    const dayOfWeek = now.toLocaleDateString('en-US', { timeZone: timezone, weekday: 'long' }).toLowerCase();
    
    const dayConfig = hours[dayOfWeek];
    if (!dayConfig || !dayConfig.enabled) return false;
    
    const currentTime = timeStr.slice(0, 5); // HH:MM format
    return currentTime >= dayConfig.start && currentTime <= dayConfig.end;
  };

  /* Call State Monitoring */
  const updateCallState = async () => {
    if (!currentSid) {
      log('updateCallState: No currentSid, skipping');
      return;
    }
    
    try {
      const stateResponse = await fetch(`/call-state/${currentSid}`);
      if (!stateResponse.ok) {
        log(`Call state fetch failed: ${stateResponse.status}`);
        return;
      }
      const state = await stateResponse.json();
      
      // Store the last call state for disconnect handling
      window.lastCallState = state;
      
      // Log state changes
      if (state.status !== window.lastCallStatus) {
        log(`ğŸ“ Call state changed: ${window.lastCallStatus || 'none'} â†’ ${state.status}`);
        window.lastCallStatus = state.status;
      }
      
      // Update UI based on state
      if (state.status === 'dialing') {
        dmvStatusValue.textContent = 'Dialing...';
        statusTitle.textContent = `ğŸ“ Calling ${state.profile ? state.profile.name : 'DMV'}...`;
      } else if (state.status === 'listening') {
        dmvStatusValue.textContent = 'Listening...';
        statusTitle.textContent = 'ğŸ‘‚ Listening for response...';
      } else if (state.status === 'agents_busy') {
        dmvStatusValue.textContent = 'All agents busy';
        statusTitle.textContent = 'â¸ï¸ Agents Busy - Will Redial';
        
        // Play agents busy sound
        soundManager.playAlert('agentsBusy');
        
        // Check if auto-hangup is enabled
        const autoHangupEnabled = localStorage.getItem('dialbot-auto-hangup') !== 'false';
        
        if (state.shouldRedial) {
          if (autoHangupEnabled) {
            log('âš ï¸ Agents busy detected - Auto-hanging up in 3 seconds...');
            // Add system message to transcript
            // Update status to show agents busy
            dmvStatusValue.textContent = 'Agents busy - auto-hanging up...';
            
            // Auto-hangup after 3 seconds
            setTimeout(async () => {
              log('ğŸ”´ Auto-hanging up due to agents busy');
              await endCurrentCall();
              scheduleRedial();
            }, 3000);
          } else {
            log('âš ï¸ Agents busy detected - Will redial after you hang up');
            // Add system message to transcript
            // Update status to show agents busy
            dmvStatusValue.textContent = 'Agents busy - will redial after hang up';
          }
        }
      } else if (state.status === 'ivr_detected') {
        dmvStatusValue.textContent = 'IVR System Detected';
        statusTitle.textContent = `ğŸ¤– Navigating ${state.profile ? state.profile.name : 'DMV'} Menu...`;
      } else if (state.status === 'listening') {
        dmvStatusValue.textContent = 'Listening for menu...';
        statusTitle.textContent = 'ğŸ‘‚ Waiting for menu options...';
      } else if (state.status === 'human_detected') {
        dmvStatusValue.textContent = 'Connected';
        humanStatusValue.textContent = 'âœ… Human Detected!';
        statusTitle.textContent = 'ğŸ‰ Human Agent Detected!';
        // Add visual emphasis
        callInfo.classList.add('human-detected');
        // Play alert sound
        playHumanDetectedAlert();
      } else if (state.status === 'waiting') {
        dmvStatusValue.textContent = 'On Hold';
        statusTitle.textContent = 'â³ Waiting for Agent...';
      } else if (state.status === 'connected') {
        dmvStatusValue.textContent = 'Connected';
        statusTitle.textContent = 'ğŸ“ Connected - Listening';
        humanStatusValue.textContent = state.humanDetected ? 'âœ… Human Detected!' : 'Waiting for agent...';
        
        // Enable controls now that we're connected
        if (true) {
          sayAgentBtn.disabled = false;
        }
      }
      
      // Update human detection status
      if (state.humanDetected) {
        humanStatusValue.textContent = 'âœ… Human Detected!';
      }
      
      // Update recording status
      if (state.recordingStatus) {
        updateRecordingStatus(state.recordingStatus);
      }
      
      // Store recordings for display
      if (state.recordings && state.recordings.length > 0) {
        window.callRecordings = state.recordings;
      }
      
      // No longer handling transcriptions - using recording status instead
    } catch (err) {
      console.error('Failed to fetch call state:', err);
    }
  };

  /* Client-side Pattern Detection */
  const startPatternDetection = () => {
    // Pattern detection is now handled server-side only
    log('âœ… Server-side pattern detection active');
  };
  
  const stopPatternDetection = () => {
    // Pattern detection is handled server-side, nothing to stop
    log('â„¹ï¸ Server-side pattern detection continues via Twilio');
  };
  
  
  /* Human Detection Alert */
  const playHumanDetectedAlert = () => {
    // Play sound using sound manager
    soundManager.playAlert('humanDetected');
    
    // Also show browser notification if permitted
    if (Notification.permission === 'granted') {
      new Notification('DMV Human Agent Detected!', {
        body: 'A human agent is now on the line!',
        icon: 'â˜ï¸'
      });
    }
  };
  
  /* Update Recording Status */
  const updateRecordingStatus = (status) => {
    const recordingStatus = document.getElementById('recordingStatus');
    if (!recordingStatus) return;
    
    if (status === 'recording') {
      recordingStatus.classList.add('recording');
      recordingStatus.innerHTML = `
        <div class="status-placeholder">
          <span class="status-icon">ğŸ”´</span>
          <span class="status-text">Recording in progress...</span>
        </div>
      `;
    } else if (status === 'completed') {
      recordingStatus.classList.remove('recording');
      recordingStatus.innerHTML = `
        <div class="status-placeholder">
          <span class="status-icon">âœ…</span>
          <span class="status-text">Recording saved</span>
        </div>
      `;
    } else if (status === 'failed') {
      recordingStatus.classList.remove('recording');
      recordingStatus.innerHTML = `
        <div class="status-placeholder">
          <span class="status-icon">âŒ</span>
          <span class="status-text">Recording failed</span>
        </div>
      `;
    } else {
      recordingStatus.classList.remove('recording');
      recordingStatus.innerHTML = `
        <div class="status-placeholder">
          <span class="status-icon">â­•</span>
          <span class="status-text">Ready to record</span>
        </div>
      `;
    }
  };

  /* Call Timer */
  const updateCallTimer = () => {
    if (!callStartTime) return;
    const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    callTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  };

  /* Device enumeration */
  const populateDevices = async () => {
    try {
      // Request permissions first
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // Important: Stop the stream after getting permission
      stream.getTracks().forEach(track => track.stop());
      
      // Small delay to ensure devices are ready
      await new Promise(resolve => setTimeout(resolve, 100));
      
      const devices = await navigator.mediaDevices.enumerateDevices();
      
      // Clear existing options
      speakerSelect.innerHTML = '<option value="">Select speaker...</option>';
      micSelect.innerHTML = '<option value="">Select microphone...</option>';
      
      devices.forEach(device => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.textContent = device.label || `${device.kind} ${device.deviceId.slice(0, 8)}`;
        
        if (device.kind === 'audiooutput') {
          speakerSelect.appendChild(option);
        } else if (device.kind === 'audioinput') {
          micSelect.appendChild(option);
        }
      });
      
      log('Audio devices enumerated');
      
      // Try to restore saved devices after enumeration
      restoreSavedDevices();
      
    } catch (err) {
      log(`Device enumeration error: ${err.message}`);
      status.textContent = 'âš ï¸ Microphone access required';
    }
  };

  /* Settings Management */
  const restoreSavedDevices = () => {
    const savedSpeakerId = localStorage.getItem('dialbot-speaker');
    const savedSpeakerLabel = localStorage.getItem('dialbot-speaker-label');
    const savedMicId = localStorage.getItem('dialbot-mic');
    const savedMicLabel = localStorage.getItem('dialbot-mic-label');
    
    let devicesRestored = false;
    
    // Try to restore speaker
    if (savedSpeakerId || savedSpeakerLabel) {
      for (let option of speakerSelect.options) {
        if ((savedSpeakerId && option.value === savedSpeakerId) || 
            (savedSpeakerLabel && option.text === savedSpeakerLabel)) {
          speakerSelect.value = option.value;
          devicesRestored = true;
          break;
        }
      }
    }
    
    // Try to restore mic
    if (savedMicId || savedMicLabel) {
      for (let option of micSelect.options) {
        if ((savedMicId && option.value === savedMicId) || 
            (savedMicLabel && option.text === savedMicLabel)) {
          micSelect.value = option.value;
          devicesRestored = true;
          break;
        }
      }
    }
    
    if (devicesRestored && speakerSelect.value && micSelect.value) {
      // Use a small delay to ensure Twilio Device is ready
      setTimeout(() => {
        updateAudioDevices();
        log('Audio devices restored from saved settings');
      }, 100);
    }
  };
  
  const loadSettings = () => {
    const savedRedialDelay = localStorage.getItem('dialbot-redial-delay');
    const savedBusinessHours = localStorage.getItem('dialbot-business-hours');
    const disableBusinessHours = localStorage.getItem('dialbot-disable-business-hours');
    
    if (savedRedialDelay) {
      redialDelay = parseInt(savedRedialDelay);
      redialIntervalSelect.value = savedRedialDelay;
    }
    
    // Load business hours disabled state
    if (disableBusinessHours === 'true') {
      $('disableBusinessHours').checked = true;
    }
    
    // Load auto-hangup setting (default to true)
    const autoHangup = localStorage.getItem('dialbot-auto-hangup');
    if (autoHangup === 'false') {
      autoHangupCheckbox.checked = false;
    } else {
      autoHangupCheckbox.checked = true; // Default to checked
    }
    
    // Load business hours
    if (savedBusinessHours) {
      try {
        const hours = JSON.parse(savedBusinessHours);
        if (hours.timezone) $('timezone').value = hours.timezone;
        
        ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].forEach(day => {
          if (hours[day]) {
            $(day).checked = hours[day].enabled;
            $(`${day}-start`).value = hours[day].start;
            $(`${day}-end`).value = hours[day].end;
          }
        });
      } catch (e) {
        console.error('Failed to load business hours:', e);
      }
    }
    
    // Load alert sound preferences
    if (soundManager.preferences) {
      $('alertVolume').value = soundManager.preferences.volume || 'normal';
      $('humanDetectedSound').value = soundManager.preferences.humanDetected || 'chime';
      $('callConnectedSound').value = soundManager.preferences.callConnected || 'beep';
      $('agentsBusySound').value = soundManager.preferences.agentsBusy || 'doubleBeep';
    }
  };

  const saveSettings = () => {
    // Save device IDs and labels for better persistence
    const selectedSpeaker = speakerSelect.selectedOptions[0];
    const selectedMic = micSelect.selectedOptions[0];
    
    localStorage.setItem('dialbot-speaker', speakerSelect.value);
    localStorage.setItem('dialbot-speaker-label', selectedSpeaker?.text || '');
    localStorage.setItem('dialbot-mic', micSelect.value);
    localStorage.setItem('dialbot-mic-label', selectedMic?.text || '');
    localStorage.setItem('dialbot-redial-delay', redialIntervalSelect.value);
    redialDelay = parseInt(redialIntervalSelect.value);
    
    // Save business hours
    const businessHours = {
      timezone: $('timezone').value,
      monday: { enabled: $('monday').checked, start: $('monday-start').value, end: $('monday-end').value },
      tuesday: { enabled: $('tuesday').checked, start: $('tuesday-start').value, end: $('tuesday-end').value },
      wednesday: { enabled: $('wednesday').checked, start: $('wednesday-start').value, end: $('wednesday-end').value },
      thursday: { enabled: $('thursday').checked, start: $('thursday-start').value, end: $('thursday-end').value },
      friday: { enabled: $('friday').checked, start: $('friday-start').value, end: $('friday-end').value },
      saturday: { enabled: $('saturday').checked, start: $('saturday-start').value, end: $('saturday-end').value },
      sunday: { enabled: $('sunday').checked, start: $('sunday-start').value, end: $('sunday-end').value }
    };
    localStorage.setItem('dialbot-business-hours', JSON.stringify(businessHours));
    
    // Save business hours disabled state
    localStorage.setItem('dialbot-disable-business-hours', $('disableBusinessHours').checked.toString());
    
    // Save auto-hangup setting
    localStorage.setItem('dialbot-auto-hangup', autoHangupCheckbox.checked.toString());
    
    // Save alert sound preferences
    soundManager.preferences.volume = $('alertVolume').value;
    soundManager.preferences.humanDetected = $('humanDetectedSound').value;
    soundManager.preferences.callConnected = $('callConnectedSound').value;
    soundManager.preferences.agentsBusy = $('agentsBusySound').value;
    soundManager.savePreferences();
    
    log(`Settings saved - Redial: ${formatTime(redialDelay)}`);
    updateAudioDevices();
    settingsModal.style.display = 'none';
    
    // Update status to reflect business hours setting
    const businessHoursDisabled = $('disableBusinessHours').checked;
    if (deviceReady && speakerSelect.value && micSelect.value) {
      status.textContent = businessHoursDisabled ? 'âœ… Ready to dial ğŸš« (Hours disabled)' : 'âœ… Ready to dial';
    }
  };

  /* Modal handlers */
  settingsBtn.onclick = () => {
    loadSettings();
    settingsModal.style.display = 'block';
  };

  settingsModal.querySelector('.close').onclick = () => {
    settingsModal.style.display = 'none';
  };

  window.onclick = (e) => {
    if (e.target === settingsModal) {
      settingsModal.style.display = 'none';
    }
  };

  saveSettingsBtn.onclick = saveSettings;
  
  /* Alert Sound Test Handlers */
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('test-sound-btn')) {
      const soundType = e.target.parentElement.querySelector('select').value;
      if (soundType !== 'none') {
        soundManager.testSound(soundType);
      }
    }
  });
  
  /* Business Hours Checkbox Handlers */
  ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].forEach(day => {
    const checkbox = $(day);
    const startInput = $(`${day}-start`);
    const endInput = $(`${day}-end`);
    
    // Set initial opacity for unchecked days
    if (!checkbox.checked) {
      startInput.style.opacity = '0.5';
      endInput.style.opacity = '0.5';
    }
    
    checkbox.addEventListener('change', () => {
      startInput.disabled = !checkbox.checked;
      endInput.disabled = !checkbox.checked;
      if (!checkbox.checked) {
        startInput.style.opacity = '0.5';
        endInput.style.opacity = '0.5';
      } else {
        startInput.style.opacity = '1';
        endInput.style.opacity = '1';
      }
    });
  });

  /* 1ï¸âƒ£  Config + token + default number */
  const config = await fetch('/config').then(r=>r.json());
  redialDelay = config.redialDelayMs || 60000;
  const { token } = await fetch('/token').then(r=>r.json());
  
  // Check for default number from environment
  const { number: defaultNumber } = await fetch('/default-number').then(r=>r.json());
  if (defaultNumber) {
    phoneInp.value = defaultNumber;
    phoneInp.placeholder = defaultNumber;
  }

  // Set default redial interval in dropdown
  redialIntervalSelect.value = redialDelay.toString();

  /* 2ï¸âƒ£  Twilio Device Setup */
  // Function to reinitialize Twilio Device with correct microphone
  const initializeTwilioDevice = async (token, forceMicId = null) => {
    const micId = forceMicId || localStorage.getItem('dialbot-mic');
    const micLabel = localStorage.getItem('dialbot-mic-label');
    
    // CRITICAL: Pre-activate the microphone to ensure browser uses it
    if (micId && micId !== '') {
      try {
        log('Pre-activating microphone to ensure browser selection...');
        const testStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            deviceId: { exact: micId }
          }
        });
        
        // Verify we got the right device
        const tracks = testStream.getAudioTracks();
        if (tracks.length > 0) {
          const settings = tracks[0].getSettings();
          log(`Pre-activated mic: ${tracks[0].label}, ID: ${settings.deviceId}`);
        }
        
        // Keep the stream active for a moment to ensure browser remembers the selection
        setTimeout(() => {
          testStream.getTracks().forEach(track => track.stop());
        }, 500);
      } catch (err) {
        log(`Failed to pre-activate microphone: ${err.message}`);
      }
    }
    
    const setupOptions = {
      debug: false,
      closeProtection: false,
      enableRingingState: true,
      // Add edge location for better audio quality
      edge: 'ashburn'
    };
    
    // If we have a saved mic, add rtcConstraints for Twilio v1.x
    if (micId && micId !== '') {
      // Use ideal instead of exact for better compatibility
      setupOptions.rtcConstraints = {
        audio: {
          deviceId: { ideal: micId },
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        },
        video: false
      };
      log(`Initializing Twilio Device with microphone: ${micLabel || micId}`);
    }
    
    isInitializingDevice = true;
    Twilio.Device.setup(token, setupOptions);
  };
  
  // Initial setup
  initializeTwilioDevice(token);
  
  // Enable audio (remove the previous disabling lines)
  // Audio devices will be set when user selects them


  Twilio.Device.on('ready', async ()=>{
    deviceReady = true;
    isInitializingDevice = false;
    status.classList.remove('loading');
    log('Device ready');
    
    // Debug: Check available Twilio Device audio APIs
    if (Twilio.Device.audio) {
      log(`Twilio audio APIs available: ${Object.keys(Twilio.Device.audio).join(', ')}`);
      if (Twilio.Device.audio.inputDevice) {
        log('Input device API is available');
      }
    }
    
    // Start by populating devices (this will also restore saved devices)
    await populateDevices();
    
    // Load profiles
    await loadProfiles();
    
    // Load other settings
    loadSettings();
    
    // Load call history
    updateCallHistoryUI();
    
    // Start token refresh timer
    startTokenRefresh();
    
    // Request notification permission
    if (Notification.permission === 'default') {
      Notification.requestPermission();
    }
  });
  
  Twilio.Device.on('error', e=>{
    status.textContent='âŒ Device error'; 
    status.classList.remove('loading');
    log(`Device error: ${e.message}`);
  });
  
  
  Twilio.Device.on('incoming', async conn=>{
    // This is the critical moment - we're receiving the browser connection from Twilio
    const savedMicId = localStorage.getItem('dialbot-mic');
    const savedMicLabel = localStorage.getItem('dialbot-mic-label');
    
    log(`ğŸ“ Incoming connection from Twilio - Need to connect microphone: ${savedMicLabel || 'default'}`);
    
    
    
    // IMPORTANT: For Twilio v1.x, we need to pass parameters when accepting
    const acceptOptions = {};
    
    // Try to set constraints during accept
    if (savedMicId && savedMicId !== '') {
      acceptOptions.rtcConstraints = {
        audio: {
          deviceId: { exact: savedMicId }
        },
        video: false
      };
      log(`Accepting with rtcConstraints for mic: ${savedMicId}`);
    }
    
    // Accept the connection with constraints
    conn.accept(acceptOptions);
    activeConn=conn; 
    endBtn.disabled=false; 
    retryBtn.disabled=false; 
    sayAgentBtn.disabled=false;
    enablePad(true);
    status.textContent='ğŸ”Š Connected to call';
    
    // Update UI immediately since we're connecting right away
    statusTitle.textContent = 'ğŸ“ Connected - Listening';
    dmvStatusValue.textContent = 'Connected';
    humanStatusValue.textContent = 'Detecting speaker...';
    
    // Update recording status to show we're connected
    updateRecordingStatus('none');
    
    // Play call connected sound
    soundManager.playAlert('callConnected');
    
    // Show that audio is connected
    log('ğŸ”Š Audio connected - you can hear the call');
    
    
    
    // Start client-side speech recognition for pattern detection
    startPatternDetection();
    
    // Verify what actually happened
    setTimeout(() => {
      if (activeConn && activeConn.mediaStream) {
        const audioTracks = activeConn.mediaStream.getAudioTracks();
        log(`Active audio tracks: ${audioTracks.length}`);
        if (audioTracks.length > 0) {
          const track = audioTracks[0];
          const settings = track.getSettings();
          log(`âœ… Connected with mic: ${track.label || 'Unknown'}, ID: ${settings.deviceId || 'Unknown'}`);
          
          // Check if it's the right device
          if (savedMicId && settings.deviceId !== savedMicId) {
            log(`âš ï¸ Warning: Connected with different mic than selected!`);
            log(`   Selected: ${savedMicId}`);
            log(`   Active: ${settings.deviceId}`);
          }
        }
      } else {
        log('âš ï¸ Warning: No media stream available on connection');
      }
    }, 500);
    
    conn.on('disconnect', ()=>{ 
      log('Call disconnected');
      
      // Add to call history
      if (callStartTime) {
        const duration = Date.now() - callStartTime;
        const status = humanStatusValue.textContent.includes('Human Detected') ? 'Connected' : 'No Agent';
        addToCallHistory(lastNumber, duration, status);
      }
      
      // Check if we should redial from multiple sources
      const shouldRedialStorage = sessionStorage.getItem('dialbot-should-redial');
      const callState = window.lastCallState; // Use the last known call state
      
      if (shouldRedialStorage === 'true' || (callState && callState.shouldRedial)) {
        sessionStorage.removeItem('dialbot-should-redial');
        log('ğŸ“ Call disconnected - Agents were busy, scheduling redial');
        log(`Redial flag from storage: ${shouldRedialStorage}`);
        log(`Redial flag from call state: ${callState?.shouldRedial}`);
        scheduleRedial();
      } else {
        log('ğŸ“ Call disconnected - Normal end, resetting UI');
        resetUI();
      }
      
      // Stop pattern detection
      stopPatternDetection();
    });
  });

  /* Audio Device Selection Handlers */
  const updateAudioDevices = async () => {
    if (!deviceReady || isInitializingDevice) return;
    
    const speakerId = speakerSelect.value;
    const micId = micSelect.value;
    
    try {
      // Set speaker device
      if (speakerId) {
        await Twilio.Device.audio.speakerDevices.set([speakerId]);
        log(`Speaker set: ${speakerSelect.selectedOptions[0]?.text}`);
      }
      
      // For microphone changes, we need to reinitialize Twilio Device
      if (micId) {
        const micLabel = micSelect.selectedOptions[0]?.text;
        log(`Microphone selected: ${micLabel}`);
        
        // Check if we need to reinitialize (mic changed)
        const currentMicId = localStorage.getItem('dialbot-mic');
        if (currentMicId !== micId && !activeConn) {
          log('Microphone changed - reinitializing Twilio Device...');
          
          // Destroy current device
          Twilio.Device.destroy();
          deviceReady = false;
          
          // Get a fresh token and reinitialize
          try {
            const { token } = await fetch('/token').then(r=>r.json());
            initializeTwilioDevice(token, micId);
          } catch (err) {
            log(`Failed to reinitialize: ${err.message}`);
          }
        }
      }
      
      // Enable call button if both devices are selected
      if (speakerId && micId) {
        callBtn.disabled = false;
        const businessHoursDisabled = localStorage.getItem('dialbot-disable-business-hours') === 'true';
        status.textContent = businessHoursDisabled ? 'âœ… Ready to dial ğŸš« (Hours disabled)' : 'âœ… Ready to dial';
      }
    } catch (err) {
      // Check if it's the specific device not found error
      if (err.message.includes('Devices not found')) {
        log('Note: Device IDs may have changed, re-enumerating...');
        await populateDevices();
      } else {
        log(`Audio device error: ${err.message}`);
        status.textContent = 'âš ï¸ Audio device setup failed';
      }
    }
  };

  speakerSelect.onchange = updateAudioDevices;
  micSelect.onchange = updateAudioDevices;
  refreshDevicesBtn.onclick = populateDevices;
  
  /* Microphone Test */
  testMicBtn.onclick = async () => {
    const micId = micSelect.value;
    if (!micId) {
      alert('Please select a microphone first');
      return;
    }
    
    try {
      log('Starting microphone test...');
      
      // Get a stream with the specific microphone
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          deviceId: { exact: micId }
        }
      });
      
      // Get the actual device being used
      const tracks = stream.getAudioTracks();
      if (tracks.length > 0) {
        const settings = tracks[0].getSettings();
        log(`Mic test - Using: ${tracks[0].label}, ID: ${settings.deviceId}`);
        
        // Create audio context to visualize audio level
        const audioContext = new AudioContext();
        const analyser = audioContext.createAnalyser();
        const microphone = audioContext.createMediaStreamSource(stream);
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        microphone.connect(analyser);
        
        // Monitor audio levels for 3 seconds
        let maxLevel = 0;
        const checkLevel = () => {
          analyser.getByteFrequencyData(dataArray);
          const level = Math.max(...dataArray);
          if (level > maxLevel) maxLevel = level;
        };
        
        const interval = setInterval(checkLevel, 100);
        
        // Show test status
        testMicBtn.textContent = 'ğŸ”´ Testing... Speak now!';
        testMicBtn.disabled = true;
        
        setTimeout(() => {
          clearInterval(interval);
          stream.getTracks().forEach(track => track.stop());
          audioContext.close();
          
          testMicBtn.textContent = 'ğŸ¤ Test Microphone';
          testMicBtn.disabled = false;
          
          if (maxLevel > 10) {
            log(`Mic test successful! Max level: ${maxLevel}`);
            alert('Microphone is working! Audio detected.');
          } else {
            log(`Mic test - No audio detected. Max level: ${maxLevel}`);
            alert('No audio detected. Please check:\n1. Microphone is not muted\n2. Correct device is selected\n3. Audio interface is properly connected');
          }
        }, 3000);
      }
    } catch (err) {
      log(`Mic test error: ${err.message}`);
      alert(`Microphone test failed: ${err.message}`);
      testMicBtn.textContent = 'ğŸ¤ Test Microphone';
      testMicBtn.disabled = false;
    }
  };

  /* 3ï¸âƒ£  Keypad */
  "123456789*0#".split('').forEach(d=>{
    const b=document.createElement('button');
    b.textContent=d; b.disabled=true;
    b.onclick=()=>{ activeConn?.sendDigits(d); log(`DTMF: ${d}`); };
    padDiv.appendChild(b);
  });
  const enablePad = on => padDiv.querySelectorAll('button')
                                .forEach(btn=>btn.disabled=!on);

  /* 4ï¸âƒ£  Call helpers */
  async function startCall(num){
    // Check business hours
    if (!isWithinBusinessHours()) {
      status.textContent = 'ğŸ• DMV is closed';
      log('Cannot call - outside business hours');
      const disableOption = confirm('DMV is currently closed. Would you like to disable business hours enforcement and call anyway?');
      if (disableOption) {
        localStorage.setItem('dialbot-disable-business-hours', 'true');
        $('disableBusinessHours').checked = true;
        log('Business hours enforcement disabled');
        // Proceed with the call
      } else {
        return;
      }
    }
    
    // Initialize audio context on user gesture
    try {
      await initAudioContext();
    } catch (err) {
      log(`AudioContext error: ${err.message}`);
    }
    
    lastNumber=num; callBtn.disabled=true;
    status.textContent='ğŸ“ Dialingâ€¦'; 
    log(`=== STARTING CALL ===`);
    log(`Dial â†’ ${num}`);
    log(`Is redial: ${redialCount > 0}`);
    
    // Clear any existing call state
    currentSid = null;
    activeConn = null;
    
    // Show call info
    callInfo.style.display = 'block';
    callInfo.classList.add('call-active');
    statusTitle.textContent = `ğŸ“ Calling ${currentProfile ? currentProfile.name : 'DMV'}...`;
    dmvStatusValue.textContent = 'Dialing...';
    humanStatusValue.textContent = 'Not detected';
    
    // Update recording status to show we're ready to record
    updateRecordingStatus('none');
    
    // Start call timer
    callStartTime = Date.now();
    callTimerInterval = setInterval(updateCallTimer, 1000);
    
    // For outbound calls, we need to explicitly set up the connection parameters
    const savedMicId = localStorage.getItem('dialbot-mic');
    const savedMicLabel = localStorage.getItem('dialbot-mic-label');
    
    // Log what we're about to use
    log(`Preparing outbound call with mic: ${savedMicLabel || savedMicId || 'default'}`);
    
    // First, ensure Twilio Device is using the correct input device
    // For Twilio Client v1.13, we need to reinitialize the device with the correct constraints
    if (savedMicId) {
      log('Note: Twilio Client v1.13 requires device reinitialization for mic changes');
      // The microphone was already set during Device.setup with rtcConstraints
      // Log the current audio input devices to verify
      if (Twilio.Device.audio && Twilio.Device.audio.availableInputDevices) {
        const inputDevices = Twilio.Device.audio.availableInputDevices;
        log(`Available input devices: ${Object.keys(inputDevices).length}`);
      }
    }
    
    log('Sending POST /call request...');
    const callResponse = await fetch('/call',{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({
        phoneNumber:num,
        profileId: currentProfile ? currentProfile.id : null
      })
    });
    
    if (!callResponse.ok) {
      const error = await callResponse.text();
      log(`âŒ Call creation failed: ${error}`);
      status.textContent = 'âŒ Call failed';
      callBtn.disabled = false;
      return;
    }
    
    const { callSid } = await callResponse.json();
    currentSid=callSid;
    log(`âœ… Call created: ${callSid}`);
    endBtn.disabled=false; retryBtn.disabled=false;
    
    // Start monitoring call state (faster polling to catch status changes)
    log('Starting call state monitoring...');
    updateCallState(); // Call immediately
    callStateInterval = setInterval(updateCallState, 1000);
  }

  async function endCurrentCall(){
    if(currentSid){
      await fetch('/end-call',{
        method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify({callSid:currentSid})
      });
    }
    if(activeConn) activeConn.disconnect();
  }

  function scheduleRedial(){
    // First reset UI but keep redial state
    resetUI(true);
    
    const redialTime = Date.now() + redialDelay;
    
    // Show redial timer
    redialTimer.style.display = 'block';
    statusTitle.textContent = 'â¸ï¸ Agents Busy - Will Redial';
    dmvStatusValue.textContent = 'Waiting to redial';
    
    // Update countdown every second
    const updateCountdown = () => {
      const remaining = redialTime - Date.now();
      if (remaining <= 0) {
        clearInterval(redialCountdownInterval);
        redialCountdownInterval = null;
        redialCountdown.textContent = '00:00';
        redialTimer.style.display = 'none';
        redialCount++;
        log(`â‡ª Redial #${redialCount} - Starting redial now`);
        
        // Add a small delay to ensure device is ready
        setTimeout(() => {
          if (deviceReady) {
            log('Device ready, initiating redial call');
            startCall(lastNumber);
          } else {
            log('âš ï¸ Device not ready for redial, aborting');
            resetUI();
          }
        }, 500);
      } else {
        const seconds = Math.ceil(remaining / 1000);
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        redialCountdown.textContent = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }
    };
    
    updateCountdown();
    redialCountdownInterval = setInterval(updateCountdown, 1000);
    
    redialTimerId = setTimeout(() => {
      redialTimerId = null;
      clearInterval(redialCountdownInterval);
      redialCountdownInterval = null;
    }, redialDelay);
    
    status.textContent = `ğŸ”„ Redialing in ${formatTime(redialDelay)}â€¦`;
    log(`Redial scheduled (${formatTime(redialDelay)})`);
    callBtn.disabled = true; retryBtn.disabled = true; endBtn.disabled = true; enablePad(false);
  }
  
  const clearRedial = () => { 
    if (redialTimerId) { 
      clearTimeout(redialTimerId); 
      redialTimerId = null; 
    }
    if (redialCountdownInterval) {
      clearInterval(redialCountdownInterval);
      redialCountdownInterval = null;
    }
    redialTimer.style.display = 'none';
  };

  function resetUI(skipRedialClear = false){
    if (!skipRedialClear) clearRedial(); 
    activeConn=currentSid=null; enablePad(false);
    
    // Clear monitoring intervals
    if (callStateInterval) {
      clearInterval(callStateInterval);
      callStateInterval = null;
    }
    if (callTimerInterval) {
      clearInterval(callTimerInterval);
      callTimerInterval = null;
    }
    
    sayAgentBtn.disabled = true;
    
    
    
    // Reset call info but keep visible
    if (callInfo) {
      callInfo.classList.remove('call-active');
      callInfo.classList.remove('human-detected');
    }
    
    // Only update status if not in redial mode
    if (!skipRedialClear) {
      statusTitle.textContent = 'ğŸ“ Ready';
      dmvStatusValue.textContent = '-';
      humanStatusValue.textContent = '-';
      const businessHoursDisabled = localStorage.getItem('dialbot-disable-business-hours') === 'true';
      const baseStatus = speakerSelect.value && micSelect.value ? 'âœ… Ready to dial' : 'âœ… Ready - Configure settings first';
      status.textContent = businessHoursDisabled ? `${baseStatus} ğŸš« (Hours disabled)` : baseStatus;
    }
    
    callStartTime = null;
    
    // Only enable call button if devices are selected and not redialing
    const devicesSelected = speakerSelect.value && micSelect.value;
    callBtn.disabled = !devicesSelected || skipRedialClear;
    endBtn.disabled=true; retryBtn.disabled=true;
  }

  /* 5ï¸âƒ£  Buttons */
  const handleCallStart = async ()=>{
    const n=phoneInp.value.trim();
    if(!n){ status.textContent='âš ï¸ Enter a valid number'; return; }
    
    if(!speakerSelect.value || !micSelect.value) {
      status.textContent='âš ï¸ Configure audio devices in settings first';
      return;
    }
    
    startCall(n);
  };

  callBtn.onclick = handleCallStart;
  endBtn.onclick   = async()=>{ await endCurrentCall(); resetUI(); };
  retryBtn.onclick = async()=>{
    if(!activeConn && !currentSid) return;
    await endCurrentCall(); scheduleRedial();
  };
  

  
  // Say Agent button handler
  sayAgentBtn.onclick = async () => {
    if (!currentSid || !activeConn) return;
    
    try {
      sayAgentBtn.disabled = true;
      sayAgentBtn.textContent = 'â³ Saying...';
      
      // Call the new say-agent endpoint
      const response = await fetch(`/say-agent/${currentSid}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to say Agent');
      }
      
      const result = await response.json();
      log('ğŸ—£ï¸ Successfully said "Agent" into the call');
      
      // Log that we said "Agent"
      log('ğŸ—£ï¸ Said "Agent" (twice)');
      
      setTimeout(() => {
        sayAgentBtn.disabled = false;
        sayAgentBtn.textContent = 'ğŸ—£ï¸ Say "Agent"';
      }, 3000); // Give it a bit more time for the audio to play
    } catch (err) {
      log(`Error saying Agent: ${err.message}`);
      sayAgentBtn.disabled = false;
      sayAgentBtn.textContent = 'ğŸ—£ï¸ Say "Agent"';
    }
  };

  // Handle Enter key in phone input
  phoneInp.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !callBtn.disabled) {
      e.preventDefault();
      handleCallStart();
    }
  });
  
  
  /* Phonebook Management */
  const loadPhonebook = () => {
    const saved = localStorage.getItem('dialbot-phonebook');
    return saved ? JSON.parse(saved) : [];
  };
  
  const savePhonebook = (phonebook) => {
    localStorage.setItem('dialbot-phonebook', JSON.stringify(phonebook));
  };
  
  const updatePhonebookUI = () => {
    const phonebook = loadPhonebook();
    
    // Update phonebook list in settings
    phonebookList.innerHTML = '';
    if (phonebook.length === 0) {
      phonebookList.innerHTML = '<div class="phonebook-empty">No contacts saved</div>';
    } else {
      phonebook.forEach((contact, index) => {
        const div = document.createElement('div');
        div.className = 'phonebook-item';
        div.innerHTML = `
          <span class="contact-name">${contact.name}</span>
          <span class="contact-number">${contact.number}</span>
          <button class="delete-contact" data-index="${index}">ğŸ—‘ï¸</button>
        `;
        phonebookList.appendChild(div);
      });
    }
    
    // Update phone select dropdown
    phoneSelect.innerHTML = '<option value="">ğŸ“– Phonebook</option>';
    phonebook.forEach(contact => {
      const option = document.createElement('option');
      option.value = contact.number;
      option.textContent = `${contact.name} (${contact.number})`;
      phoneSelect.appendChild(option);
    });
  };
  
  // Add contact
  phonebookAddBtn.onclick = () => {
    const name = phonebookName.value.trim();
    const number = phonebookNumber.value.trim();
    
    if (!name || !number) {
      alert('Please enter both name and number');
      return;
    }
    
    const phonebook = loadPhonebook();
    phonebook.push({ name, number });
    savePhonebook(phonebook);
    
    phonebookName.value = '';
    phonebookNumber.value = '';
    updatePhonebookUI();
    log(`Added contact: ${name}`);
  };
  
  // Delete contact
  phonebookList.addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-contact')) {
      const index = parseInt(e.target.dataset.index);
      const phonebook = loadPhonebook();
      const deleted = phonebook.splice(index, 1)[0];
      savePhonebook(phonebook);
      updatePhonebookUI();
      log(`Deleted contact: ${deleted.name}`);
    }
  });
  
  // Phone select handler
  phoneSelect.onchange = () => {
    if (phoneSelect.value) {
      phoneInp.value = phoneSelect.value;
      phoneSelect.value = ''; // Reset to show "Phonebook"
    }
  };
  
  // Load phonebook on startup
  updatePhonebookUI();
  
  /* Copy Logs Handler */
  copyLogsBtn.onclick = async () => {
    const logContent = logBox.textContent;
    if (!logContent.trim()) {
      alert('No logs to copy');
      return;
    }
    
    try {
      await navigator.clipboard.writeText(logContent);
      copyLogsBtn.textContent = 'âœ…';
      setTimeout(() => {
        copyLogsBtn.textContent = 'ğŸ“‹';
      }, 2000);
    } catch (err) {
      console.error('Failed to copy logs:', err);
      alert('Failed to copy logs');
    }
  };
  
  /* Copy and Clear Transcript Handlers - Disabled since we're using recordings instead */
  // Transcript functionality has been replaced with recording functionality
  
  // Recordings button handlers
  const viewRecordingsBtn = $('viewRecordings');
  const recordingsList = $('recordingsList');
  const closeRecordingsBtn = $('closeRecordings');
  const recordingsContent = $('recordingsContent');
  
  viewRecordingsBtn.onclick = () => {
    // Show recordings list
    recordingsList.style.display = 'block';
    
    // Display recordings
    if (window.callRecordings && window.callRecordings.length > 0) {
      recordingsContent.innerHTML = '';
      window.callRecordings.forEach((recording, index) => {
        const div = document.createElement('div');
        div.className = 'recording-item';
        const date = new Date(recording.timestamp).toLocaleString();
        div.innerHTML = `
          <div class="recording-date">${date}</div>
          <div class="recording-duration">Duration: ${recording.duration}s</div>
          <div class="recording-actions">
            <button onclick="window.open('${recording.url}.mp3', '_blank')">ğŸµ Play</button>
            <button onclick="window.open('${recording.url}', '_blank')">ğŸ’¾ Download</button>
          </div>
        `;
        recordingsContent.appendChild(div);
      });
    } else {
      recordingsContent.innerHTML = '<div class="recordings-placeholder">No recordings yet</div>';
    }
  };
  
  closeRecordingsBtn.onclick = () => {
    recordingsList.style.display = 'none';
  };
  
  /* Call Notes Handlers */
  // Auto-save notes to localStorage
  callNotesTextarea.addEventListener('input', () => {
    localStorage.setItem('dialbot-call-notes', callNotesTextarea.value);
  });
  
  // Load saved notes on startup
  const savedNotes = localStorage.getItem('dialbot-call-notes');
  if (savedNotes) {
    callNotesTextarea.value = savedNotes;
  }
  
  // Copy notes
  copyNotesBtn.onclick = async () => {
    const notes = callNotesTextarea.value;
    if (!notes.trim()) {
      alert('No notes to copy');
      return;
    }
    
    try {
      await navigator.clipboard.writeText(notes);
      copyNotesBtn.textContent = 'âœ… Copied!';
      setTimeout(() => {
        copyNotesBtn.textContent = 'ğŸ“‹ Copy';
      }, 2000);
    } catch (err) {
      console.error('Failed to copy notes:', err);
      alert('Failed to copy notes');
    }
  };
  
  // Export notes as .txt file
  exportNotesBtn.onclick = () => {
    const notes = callNotesTextarea.value;
    if (!notes.trim()) {
      alert('No notes to export');
      return;
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `dialbot-notes-${timestamp}.txt`;
    
    // Add call information to the export
    let exportContent = `DialBot Call Notes\n`;
    exportContent += `==================\n\n`;
    exportContent += `Date: ${new Date().toLocaleString()}\n`;
    if (lastNumber) exportContent += `Number Called: ${lastNumber}\n`;
    exportContent += `\nNotes:\n------\n${notes}`;
    
    // Create blob and download
    const blob = new Blob([exportContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    log(`Notes exported as ${filename}`);
  };
  
  // Clear notes
  clearNotesBtn.onclick = () => {
    if (callNotesTextarea.value.trim() && confirm('Clear all notes?')) {
      callNotesTextarea.value = '';
      localStorage.removeItem('dialbot-call-notes');
      log('Notes cleared');
    }
  };
})();
</script>
</body>
</html>
